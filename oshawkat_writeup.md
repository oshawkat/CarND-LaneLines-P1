# **Finding Lane Lines on the Road** 

By Osman Shawkat

### Reflection

### 1. Pipeline Description

My pipeline is composed of 7 primary components:

1. Converting input image to greyscale
1. Smoothing the image using Gaussian blurring
1. Detecting edges using the Canny algorithm
1. Applying two trapezoidal masks, one for each lane line, to remove areas outside of the target region
1. Using the Hough transform to detect lines from each edge image (left and right)
1. Filtering the detected Hough lines then projecting/extrapolating those to be drawn on the image.
1. Combine the two Hough lines and draw the best-fit lines on the image

The first three steps are generally similar to those covered in the preceding lecture, save for parameter values which were generated by trial and error on the example pictures.  I had attempted to start with masking but found that the Canny detector would see the masked edges boundaries as lines.  I did find that focusing on fine tuning the early steps (eg mask shape) made downstream processing easier and more robust.  Note that the lane lines are not centered in the camera image

To improve my results and make the pipeline more resilient to non-lane line features (eg color changes on the road in the Challenge video), I apply two separate masks, one for each lane line, and run the remainder of the pipeline on each lane line independently.  This reduces the occurrence of stray Hough lines bridging between the two actual lanes.  It also enables the algorithm to function even if there is a car ahead of the ego vehicle in the lane.

The primary differentiator for my pipeline was the addition of a Hough lines analysis.  Instead of drawing the Hough lines directly on the input image, I instead passed the lines array, as well as image dimensions, to the analyze_single_side_hough_lines() function.  This function calculates the length and slope of each line and applied a slope band filter to remove any unlikely candidates.  These filtered array of lines is then passed to find_best_line().

find_best_line() returns one line per group of lines that extends from the bottom of the image to some height (default is 40% of the image).  First, the slope is found by taking a weighted average of the slopes of the incoming lines, by line length.  From visual observation, it appeared that the bottom-left most line vertex (for left lane lines) has minimal error so I set the best line to intercept it.  With a slope and an intercept, I was able to calculate the start and end vertices for the best line.

While I suspect that most students incorporated this best-fit and extrapolation in their draw_lines() function, I prefer to keep it simple, per the function name, and not add implicit, possibly unintended, functionality.

### 2. Identify potential shortcomings with your current pipeline

It is clear from running the algorithm on the videos that there is significant flickering of the detected lane line.  This is may be partially due to lane line curvature at a distance but the problem persists even when the projected length is reduced.

I also realize that my slope calculator assumes that the input lines have x1 < x2, which works in this context but may break in other settings.

### 3. Suggest possible improvements to your pipeline

The flickering of lane lines in the video may be addressed in a variety of ways.  First, I noticed that yellow lane lines appeared to suffer the most from these issues so some additional parameter tuning on more yellow lane line example images may improve results.

This algorithm operates on a single image at a time, which, given overall vehicle motion, can result in good performance on individual images still displaying as flicker.  I would like to leverage adjacent frames and apply some line smoothing across them.

An improved best-line creator may also prove effective at reducing flicker.  I currently use the weighted average of the slope but it is still very sensitive to the intercept location, which uses information from a single data point.  Extrapolating all the filtered lines to a certain height (eg bottom of image) and taking the weighted average of the intercept may prove more robust

A possible solution to the slope calculator brittleness is to sort the inputs into the expected order before performing any calculations